//===----------------------------------------------------------------------===//
//
// NAME         : WordMatch
// SUMMARY      : Match a bunch of jumbled letters with words.
// COPYRIGHT    : (c) 2014 Sean Donnellan. All Rights Reserved.
// LICENSE      : The MIT License (see LICENSE.txt for details)
// DESCRIPTION: : This is was intended to be a solver for the Letters game in
//                Countdown.
//
//                http://en.wikipedia.org/wiki/Countdown_%28game_show%29
//
//===----------------------------------------------------------------------===//

#include "wordlist.hpp"
#include "wordlistiterator.hpp"

#include <algorithm>
#include <exception>
#include <fstream>
#include <iostream>
#include <iterator>
#include <memory>
#include <numeric>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include <cctype>
#include <cstring>

// Converts a word list into a more compressed format for faster reading.
//
// The output file only contains words of a certain length.
void ConvertWordList(std::size_t wordLength);

// Read back in the word list generated by ConvertWordList.
WordList ReadWordList(std::size_t wordLength);

unsigned char ToLower(unsigned char c);

//===----------------------------------------------------------------------===//
// Defintions for the Wordlistiterator class.
WordListIterator::WordListIterator(const WordList* list, std::size_t offset)
: index(offset),
  words(list)
{
}

WordListIterator::WordListIterator(const WordListIterator& that)
: index(that.index), words(that.words)
{
}

WordListIterator& WordListIterator::operator=(const WordListIterator& that)
{
  index = that.index;
  words = that.words;
  return *this;
}

WordListIterator::difference_type WordListIterator::operator-(
  const WordListIterator& rhs) const
{
  // Determine how many words (iterations) between this and that.
  //
  // TODO: Change the iterator to keep track of the number of words not address.
  return static_cast<difference_type>((
    index - rhs.index) / (words->length * 2 + 2));
}

bool WordListIterator::operator==(const WordListIterator& that) const
{
  return index == that.index && words == that.words;
}

char* WordListIterator::word() const
{
  return words->words.get() + index + words->length;
}

Word WordListIterator::operator*() const
{
  const Word currentWord = { words->words.get() + index, word() };
  return currentWord;
}

WordListIterator& WordListIterator::operator++()
{
  // Add the length to take into account the sorted version of the
  // word, and again for the unsorted version and then 2 characters
  // for the trailing null character and new-line.
  index += words->length + words->length + 2;
  return *this;
}

WordListIterator& WordListIterator::operator+=(difference_type wordCount)
{
  // Add the length to take into account the sorted version of the
  // word, and again for the unsorted version and then 2 characters
  // for the trailing null character and new-line.
  index += (words->length + words->length + 2) * wordCount;
  return *this;
}

//===----------------------------------------------------------------------===//
// Defintions for the Word struct.
WordList::WordList(std::ifstream& input, std::size_t inputSize)
: words(new word_type[inputSize - sizeof(length)]),
  size(inputSize - sizeof(length)),
  length(0)
{
  if (input.bad()) throw std::runtime_error("I/O error while reading");
  else if (input.eof()) throw std::runtime_error("End of file reached");
  else if (input.fail()) throw  std::runtime_error("Read failed.");

  input.read(reinterpret_cast<char*>(&length), sizeof(length));

  if (input.bad()) throw std::runtime_error("I/O error while reading");
  else if (input.eof()) throw std::runtime_error("End of file reached");
  else if (input.fail()) throw std::runtime_error("Read failed.");

input.read(words.get(), static_cast<std::streamsize>(inputSize));
}

WordListIterator WordList::begin() const { return WordListIterator(this, 0); }

WordListIterator WordList::end() const { return WordListIterator(this, size); }

// Returns matches for the word for [begin, end) which match word.
std::pair<WordListIterator, WordListIterator>
WordList::matches(std::string word) const
{
  std::pair<WordListIterator, WordListIterator> result(end(), end());

  if (word.length() != length)
  {
    // Word list doesn't contain any words that long.
    return result;
  }

  std::sort(word.begin(), word.end());
  std::transform(word.begin(), word.end(), word.begin(), ToLower);
  const auto wordLength = length;
  const auto lowerBound = [&wordLength](const Word& lhs, const std::string& rhs)
    -> bool
    {
      return std::lexicographical_compare(
        lhs.sortedWord, lhs.sortedWord + wordLength,
        rhs.cbegin(), rhs.cend());
    };

  const auto upperBound = [&wordLength](const std::string& lhs, const Word& rhs)
    -> bool
    {
      return std::lexicographical_compare(
        lhs.cbegin(), lhs.cend(),
        rhs.sortedWord, rhs.sortedWord + wordLength);
    };

  // Find the range.
  result.first = std::lower_bound(begin(), end(), word, lowerBound);
  result.second = std::upper_bound(begin(), end(), word, upperBound);
  return result;
}

template<int N>
int compare(const void* p1, const void* p2)
{
  const auto* const lhs = static_cast<const char* const>(p1);
  const auto* const rhs = static_cast<const char* const>(p2);
  return std::strncmp(lhs, rhs, N);
}

void WordList::sort()
{
  // Compare compare;
  int (*compator[])(const void*,const void*) = {
    nullptr, compare<1>, compare<2>, compare<3>, compare<4>, compare<5>,
    compare<6>, compare<7>, compare<8>, compare<9>, compare<10>,
    compare<11>, compare<12>, compare<13>, compare<14>,  compare<15>,
  };

  if (length < 16 && length > 0)
  {
    qsort(words.get(), static_cast<std::size_t>(std::distance(begin(), end())),
    length * 2 + 2, compator[length]);
  }
  else
  {
    std::cerr << "Can't compare these" << std::endl;
    std::exit(1);
  }
}

void WordList::write(std::ofstream& output) const
{
  output.write(reinterpret_cast<const char*>(&length), sizeof(length));
  output.write(words.get(), static_cast<std::streamsize>(size));
}

//===----------------------------------------------------------------------===//
// Defintion of helper methods.
WordList ReadWordList(std::size_t wordLength)
{
  std::stringstream filename;
  filename << "data/wordlist" << wordLength << ".bin";

  std::ifstream input(filename.str(), std::ios::binary | std::ios::ate);
  const std::streampos fileSize = input.tellg();
  if (input.eof() || input.bad())
  {
    throw std::runtime_error("The word list is empty.");
  }
  input.seekg(std::ios::beg);
  if (input.peek() == std::istream::traits_type::eof())
  {
    throw std::runtime_error("The word list is empty.");
  }
  return WordList(input, static_cast<std::size_t>(fileSize));
}

void ConvertWordList(std::size_t wordLength)
{
  std::stringstream outputFilename;
  outputFilename << "data/wordlist" << wordLength << ".bin";

  bool isSorted = true;
  {
    std::ifstream input("data/wordlist.txt");
    std::ofstream output(outputFilename.str(), std::ios::binary);

    std::string lastWord;

    // Write out the length of the word.
    output.write(reinterpret_cast<const char*>(&wordLength),
                 sizeof(wordLength));

    const auto optimiseWord = [&output, wordLength, &lastWord, &isSorted](
      const std::string& word)
      {
        // Ignore words which don't have a-z.
        // Ignore words with captial letters as they are likely proper nouns.

        if (wordLength == word.size() &&
            std::all_of(word.cbegin(), word.cend(), isalpha) &&
            std::all_of(word.cbegin(), word.cend(), islower))
        {
          std::string sortedWord(word);
          std::sort(sortedWord.begin(), sortedWord.end());
          std::transform(sortedWord.begin(), sortedWord.end(),
                         sortedWord.begin(), ToLower);

          if (!lastWord.empty() && !std::lexicographical_compare(
                lastWord.cbegin(), lastWord.cend(),
                sortedWord.cbegin(), sortedWord.cend()))
          {
            isSorted = false;
          }
          output.write(sortedWord.c_str(),
                       static_cast<std::streamsize>(sortedWord.size()));
          output.write(word.c_str(), static_cast<std::streamsize>(word.size()));
          // The null charachter is to make the word null-terminated and the
          // new-line is to make it easier to view the resulting file in a
          // text editor.
          output << '\0' << '\n';

          lastWord = sortedWord;
        }
      };

    std::for_each(std::istream_iterator<std::string>(input),
                  std::istream_iterator<std::string>(),
                  optimiseWord);
  }

  // If the word list is not sorted, read it back in and sort it.
  if (!isSorted)
  {
    // Read the data back-in.
    WordList words = ReadWordList(wordLength);

    // Sort it
    words.sort();

    // Write it back out.
    std::ofstream output(outputFilename.str(), std::ios::binary);
    words.write(output);
  }
}

unsigned char ToLower(unsigned char c)
{
    // Consider std::tolower(c, std::locale("en_US.utf8")) as then the cast
    // would not be required.
    return static_cast<unsigned char>(std::tolower(c));
}

//===----------------------------------------------------------------------===//
// Generates r-length subsequences of elements from an input string.
class Combination
{
  // Stores current permutation of indices into the string.
  std::unique_ptr<std::size_t[]> myIndices;

  // The length of the sub-string.
  std::size_t myLength;

  // The original string.
  std::string myBase;

public:
  Combination(const std::string& base, std::size_t length);

  // Returns the current subsequence.
  std::string current() const;

  // Returns true if there is another subsequence.
  bool next() const;
};

//===----------------------------------------------------------------------===//
// Defintions for the Combination class.
Combination::Combination(const std::string& base, std::size_t length)
  : myIndices(new std::size_t[base.size()]),
    myLength(length),
    myBase(base)
{
  std::iota(myIndices.get(), myIndices.get() + myBase.size(), 0);
  std::sort(myBase.begin(), myBase.end());
}


std::string Combination::current() const
{
  std::string value(myLength, '-');
  std::transform(myIndices.get(), myIndices.get() + myLength, value.begin(),
                 [&](std::size_t i) -> char { return myBase[i]; });
  return value;
}

bool Combination::next() const
{
  // The algorithm is as follows, each character is assigned a number
  // based on its index in the word. So "acdgot" is 012345, then it runs through
  // all the permutations of those numbers, and take first 3 numbers to form
  // a new word. It ignores it if the numbers aren't sorted i.e (1 0 2) since
  // this would be "cad" which already covered by (0, 1, 2) -> "acd".
  //
  // This is essentially from:
  //   https://docs.python.org/2/library/itertools.html#itertools.combinations

  const auto begin = myIndices.get();
  const auto end = myIndices.get() + myBase.size();

  // Generate the next permutation, and skip it if its not sorted.
  bool hasNext;
  for (hasNext = std::next_permutation(begin, end);
       !std::is_sorted(begin, begin + myLength) && hasNext;
       hasNext = std::next_permutation(begin, end));
  return hasNext;
}

int main(int argc, char* argv[]) try
{
  //std::string word("TEQSENUIE");
  //std::string word("CNLREAETU");
  std::string word("HGUOTIPSE");

  const std::size_t minimumWordSize(2);
  const std::size_t maximumWordSize(15);
  if (argc == 2)
  {
    if (std::string("--generate") == argv[1])
    {
      std::cout << "Generating word lists..." << std::endl;
      for (std::size_t i = minimumWordSize; i < maximumWordSize + 1; ++i)
      {
        ConvertWordList(i);
      }
      return 0;
    }

    word = std::string(argv[1]);
  }

  if (word.length() + 1 < minimumWordSize)
  {
    std::cerr << "Must be at least " << (minimumWordSize + 1)
              << " characters." << std::endl;
    return 1;
  }
  //if (word.length() > maximumWordSize)
  //{
  //  std::cerr << "Too many characters. Only " << maximumWordSize
  //            << " characters are supported" << std::endl;
  //  return 1;
  //}

  std::cout << "Finding words for the letters: " << word << std::endl;

  std::set<std::string> visited;
  bool foundMatch = false;
  std::cout << "Matches: " << std::endl << "  ";

  for (std::size_t i = std::min(maximumWordSize, word.length());
       i > minimumWordSize; --i)
  {
    const WordList words = ReadWordList(i);
    Combination combination(word, i);
    do
    {
      const std::string current = combination.current();
      auto visitedIterator = visited.lower_bound(current);
      if (visitedIterator == visited.end() || *visitedIterator != current)
      {
        visited.insert(visitedIterator, current);
        const auto matches = words.matches(combination.current());
        if (matches.first != matches.second)
        {
          std::ostream_iterator<const char*> out(std::cout, "\n  ");
          std::copy(matches.first, matches.second, out);
          foundMatch = true;
        }
        if (word.length() == i) break;
      }
    } while (combination.next());
  }

  if (!foundMatch)
  {
    std::cerr << "No matches found!" << std::endl;
    return 2;
  }

  return 0;
}
catch (const std::runtime_error& error)
{
  std::cerr << "Error: " << error.what() << std::endl;
  return 3;
}

//===--------------------------- End of the file --------------------------===//
